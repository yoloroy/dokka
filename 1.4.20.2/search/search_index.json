{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dokka \u00b6 Dokka is a documentation engine for Kotlin, performing the same function as javadoc for Java. Just like Kotlin itself, Dokka fully supports mixed-language Java/Kotlin projects. It understands standard Javadoc comments in Java files and KDoc comments in Kotlin files, and can generate documentation in multiple formats including standard Javadoc, HTML and Markdown. Integrations \u00b6 Dokka provides support for the following build systems: Gradle Maven Command line Note The Gradle plugin is the preferred way to use Dokka","title":"Home"},{"location":"#dokka","text":"Dokka is a documentation engine for Kotlin, performing the same function as javadoc for Java. Just like Kotlin itself, Dokka fully supports mixed-language Java/Kotlin projects. It understands standard Javadoc comments in Java files and KDoc comments in Kotlin files, and can generate documentation in multiple formats including standard Javadoc, HTML and Markdown.","title":"Dokka"},{"location":"#integrations","text":"Dokka provides support for the following build systems: Gradle Maven Command line Note The Gradle plugin is the preferred way to use Dokka","title":"Integrations"},{"location":"about/FAQ/","text":"FAQ \u00b6 If you encounter any problems, please see the FAQ .","title":"FAQ"},{"location":"about/FAQ/#faq","text":"If you encounter any problems, please see the FAQ .","title":"FAQ"},{"location":"about/slack_channel/","text":"Slack channel \u00b6 For more information or help, feel free to ask questions in the official Kotlin Slack Channel","title":"Slack channel"},{"location":"about/slack_channel/#slack-channel","text":"For more information or help, feel free to ask questions in the official Kotlin Slack Channel","title":"Slack channel"},{"location":"community/plugins-list/","text":"Dokka community plugins \u00b6 Here is a list of plugins created by dokka team or community. In order to add your plugin to this list it needs to be: an open source project - sharing is caring so let others learn and improve your plugin present in any public artefacts repository like bintray Plugin name Description Source Kotlin as Java Display Kotlin code as seen from Java Github GFM Renders documentation in a GFM format Github Javadoc Renders documentation in a Javadoc format Github Jekyll Renders documentation in a Jekyll format Github","title":"Community plugins"},{"location":"community/plugins-list/#dokka-community-plugins","text":"Here is a list of plugins created by dokka team or community. In order to add your plugin to this list it needs to be: an open source project - sharing is caring so let others learn and improve your plugin present in any public artefacts repository like bintray Plugin name Description Source Kotlin as Java Display Kotlin code as seen from Java Github GFM Renders documentation in a GFM format Github Javadoc Renders documentation in a Javadoc format Github Jekyll Renders documentation in a Jekyll format Github","title":"Dokka community plugins"},{"location":"developer_guide/data_model/","text":"Dokka Data Model \u00b6 There a four data models that Dokka uses: Documentable Model, Documentation Model, Page Model and Content Model. Documentable Model \u00b6 Documentable model represents parsed data, returned by compiler analysis. It retains basic order structure of parsed Psi or Descriptor models. After creation, it is a collection of trees, each with DModule as a root. After the Merge step, all trees are folded into one. The main building block of this model is Documentable class, that is a base class for all more specific types that represents elements of parsed Kotlin and Java classes with pretty self-explanatory names: DPackage , DFunction and so on. DClasslike is a base for class-like elements, such as Classes, Enums, Interfaces and so on. There are three non-documentable classes important for the model: DRI , SourceSetDependent and ExtraProperty . DRI (Dokka Resource Identifier) is a unique value that identifies specific Documentable . All references to other documentables different than direct ownership are described using DRIs. For example, DFunction with parameter of type X has only X's DRI, not the actual reference to X's Documentable object. SourceSetDependent is a map that handles multiplatform data, by connecting platform-specific data, declared with either expect or actual modifier, to a particular Source Set ExtraProperty is used to store any additional information that falls outside of regular model. It is highly recommended to use extras to provide any additional information when creating custom Dokka plugins. This element is a bit more complex, so you can read more about how to use it below. ExtraProperty class usage \u00b6 ExtraProperty classes are used both by Documentable and Content models. To declare a new extra, you need to implement ExtraProperty interface. interface ExtraProperty < in C : Any > { interface Key < in C : Any , T : Any > { fun mergeStrategyFor ( left : T , right : T ): MergeStrategy < C > = MergeStrategy . Fail { throw NotImplementedError ( \"Property merging for $this is not implemented\" ) } } val key : Key < C , *> } It is advised to use following pattern when declaring new extras: data class CustomExtra ( [ any values relevant to your extra ] ): ExtraProperty < Documentable > { companion object : CustomExtra . Key < Documentable , CustomExtra > override val key : CustomExtra . Key < Documentable , *> = CustomExtra } Merge strategy for extras is invoked only if merged objects have different values for same Extra. If you don't expect it to happen, you can omit implementing mergeStrategyFor function. All extras for ContentNode and Documentable classes are stored in PropertyContainer<C : Any> class instances. The C generic class parameter limits the type of properties, that can be stored in the container - it must match generic C class parameter from ExtraProperty interface. For example, if you would create DFunction -only ExtraProperty , it will be limited to be added only to PropertyContainer<DFunction> . In following example we will create Documentable -only property, store it in the container and then retrieve its value: data class CustomExtra ( val customExtraValue : String ) : ExtraProperty < Documentable > { companion object : ExtraProperty . Key < Documentable , CustomExtra > override val key : ExtraProperty . Key < Documentable , *> = CustomExtra } val extra : PropertyContainer < DFunction > = PropertyContainer . withAll ( CustomExtra ( \"our value\" ) ) val customExtraValue : String ? = extra [ CustomProperty ] ?. customExtraValue You can also use extras as markers, without storing any data in them: object MarkerExtra : ExtraProperty < Any >, ExtraProperty . Key < Any , MarkerExtra > { override val key : ExtraProperty . Key < Any , *> = this } val extra : PropertyContainer < Any > = PropertyContainer . withAll ( MarkerExtra ) val isMarked : Boolean = extra [ MarkerExtra ] != null Documentation Model \u00b6 Documentation model is used along Documentable Model to store data obtained by parsing code commentaries. There are three important classes here: DocTag describes a specific documentation syntax element, for example: header, footer, list, link, raw text, paragraph, etc. TagWrapper described a whole comment description or a specific comment tag, for example: @See, @Returns, @Author; and holds consisting DocTag elements DocumentationNode acts as a container for TagWrappers for a specific Documentable DocumentationNodes are references by a specific Documentable Page Model \u00b6 Page Model represents the structure of future generated documentation pages and is independent of the final output format, which each node corresponding to exactly one output file. Renderer is processing each page separately.Subclasses of PageNode represents different kinds of rendered pages for Modules, Packages, Classes etc. The Page Model is a tree structure, with RootPageNode being the root. Content Model \u00b6 Content Model describes how the actual page content is presented. It organizes it's structure into groups, tables, links, etc. Each node is identified by unique DCI (Dokka Content Identifier) and all references to other nodes different than direct ownership are described using DCIs. DCI aggregates DRI s of all Documentables that make up specific ContentNode . Also, all ExtraProperty info from consisting Documentable s is propagated into Content Model and available for Renderer .","title":"Data model"},{"location":"developer_guide/data_model/#dokka-data-model","text":"There a four data models that Dokka uses: Documentable Model, Documentation Model, Page Model and Content Model.","title":"Dokka Data Model"},{"location":"developer_guide/data_model/#documentable-model","text":"Documentable model represents parsed data, returned by compiler analysis. It retains basic order structure of parsed Psi or Descriptor models. After creation, it is a collection of trees, each with DModule as a root. After the Merge step, all trees are folded into one. The main building block of this model is Documentable class, that is a base class for all more specific types that represents elements of parsed Kotlin and Java classes with pretty self-explanatory names: DPackage , DFunction and so on. DClasslike is a base for class-like elements, such as Classes, Enums, Interfaces and so on. There are three non-documentable classes important for the model: DRI , SourceSetDependent and ExtraProperty . DRI (Dokka Resource Identifier) is a unique value that identifies specific Documentable . All references to other documentables different than direct ownership are described using DRIs. For example, DFunction with parameter of type X has only X's DRI, not the actual reference to X's Documentable object. SourceSetDependent is a map that handles multiplatform data, by connecting platform-specific data, declared with either expect or actual modifier, to a particular Source Set ExtraProperty is used to store any additional information that falls outside of regular model. It is highly recommended to use extras to provide any additional information when creating custom Dokka plugins. This element is a bit more complex, so you can read more about how to use it below.","title":"Documentable Model"},{"location":"developer_guide/data_model/#extraproperty-class-usage","text":"ExtraProperty classes are used both by Documentable and Content models. To declare a new extra, you need to implement ExtraProperty interface. interface ExtraProperty < in C : Any > { interface Key < in C : Any , T : Any > { fun mergeStrategyFor ( left : T , right : T ): MergeStrategy < C > = MergeStrategy . Fail { throw NotImplementedError ( \"Property merging for $this is not implemented\" ) } } val key : Key < C , *> } It is advised to use following pattern when declaring new extras: data class CustomExtra ( [ any values relevant to your extra ] ): ExtraProperty < Documentable > { companion object : CustomExtra . Key < Documentable , CustomExtra > override val key : CustomExtra . Key < Documentable , *> = CustomExtra } Merge strategy for extras is invoked only if merged objects have different values for same Extra. If you don't expect it to happen, you can omit implementing mergeStrategyFor function. All extras for ContentNode and Documentable classes are stored in PropertyContainer<C : Any> class instances. The C generic class parameter limits the type of properties, that can be stored in the container - it must match generic C class parameter from ExtraProperty interface. For example, if you would create DFunction -only ExtraProperty , it will be limited to be added only to PropertyContainer<DFunction> . In following example we will create Documentable -only property, store it in the container and then retrieve its value: data class CustomExtra ( val customExtraValue : String ) : ExtraProperty < Documentable > { companion object : ExtraProperty . Key < Documentable , CustomExtra > override val key : ExtraProperty . Key < Documentable , *> = CustomExtra } val extra : PropertyContainer < DFunction > = PropertyContainer . withAll ( CustomExtra ( \"our value\" ) ) val customExtraValue : String ? = extra [ CustomProperty ] ?. customExtraValue You can also use extras as markers, without storing any data in them: object MarkerExtra : ExtraProperty < Any >, ExtraProperty . Key < Any , MarkerExtra > { override val key : ExtraProperty . Key < Any , *> = this } val extra : PropertyContainer < Any > = PropertyContainer . withAll ( MarkerExtra ) val isMarked : Boolean = extra [ MarkerExtra ] != null","title":"ExtraProperty class usage"},{"location":"developer_guide/data_model/#documentation-model","text":"Documentation model is used along Documentable Model to store data obtained by parsing code commentaries. There are three important classes here: DocTag describes a specific documentation syntax element, for example: header, footer, list, link, raw text, paragraph, etc. TagWrapper described a whole comment description or a specific comment tag, for example: @See, @Returns, @Author; and holds consisting DocTag elements DocumentationNode acts as a container for TagWrappers for a specific Documentable DocumentationNodes are references by a specific Documentable","title":"Documentation Model"},{"location":"developer_guide/data_model/#page-model","text":"Page Model represents the structure of future generated documentation pages and is independent of the final output format, which each node corresponding to exactly one output file. Renderer is processing each page separately.Subclasses of PageNode represents different kinds of rendered pages for Modules, Packages, Classes etc. The Page Model is a tree structure, with RootPageNode being the root.","title":"Page Model"},{"location":"developer_guide/data_model/#content-model","text":"Content Model describes how the actual page content is presented. It organizes it's structure into groups, tables, links, etc. Each node is identified by unique DCI (Dokka Content Identifier) and all references to other nodes different than direct ownership are described using DCIs. DCI aggregates DRI s of all Documentables that make up specific ContentNode . Also, all ExtraProperty info from consisting Documentable s is propagated into Content Model and available for Renderer .","title":"Content Model"},{"location":"developer_guide/extension_points/","text":"Extension points \u00b6 Core extension points \u00b6 We will discuss all base extension points along with the steps, that DokkaGenerator does to build a documentation. Setting up Kotlin and Java analysis process and initializing plugins \u00b6 The provided Maven / CLI / Gradle configuration is read.Then, all the DokkaPlugin classes are loaded and the extensions are created. No entry points here. Creating documentation models \u00b6 The documentation models are created. This step uses DokkaCore.sourceToDocumentableTranslator entry point. All extensions registered using this entry point will be invoked. Each of them is required to implement SourceToDocumentableTranslator interface: interface SourceToDocumentableTranslator { fun invoke ( sourceSet : SourceSetData , context : DokkaContext ): DModule } By default, two translators are created: DefaultDescriptorToDocumentableTranslator that handles Kotlin files DefaultPsiToDocumentableTranslator that handles Java files After this step, all data from different source sets and languages are kept separately. If you are using Kotlin it is recommended to make use of the asynchronous version, providing you implementation of invokeSuspending : interface AsyncSourceToDocumentableTranslator : SourceToDocumentableTranslator { suspend fun invokeSuspending ( sourceSet : DokkaConfiguration . DokkaSourceSet , context : DokkaContext ): DModule } Pre-merge documentation transform \u00b6 Here you can apply any transformation to model data before different source sets are merged. This step uses DokkaCore.preMergeDocumentableTransformer entry point. All extensions registered using this entry point will be invoked. Each of them is required to implement PreMergeDocumentableTransformer interface: interface PreMergeDocumentableTransformer { operator fun invoke ( modules : List < DModule >, context : DokkaContext ): List < DModule > } By default, three transformers are created: DocumentableVisibilityFilter that, depending on configuration, filters out all private members from declared packages ActualTypealiasAdder that handles Kotlin typealiases ModuleAndPackageDocumentationTransformer that creates documentation content for models and packages itself Merging \u00b6 All DModule instances are merged into one. This step uses DokkaCore.documentableMerger entry point. It is required to have exactly one extension registered for this entry point. Having more will trigger an error, unless only one is not overridden. The extension is required to implement DocumentableMerger interface: interface DocumentableMerger { operator fun invoke ( modules : Collection < DModule >, context : DokkaContext ): DModule } By default, DefaultDocumentableMerger is created. This extension is treated as a fallback, so it can be overridden by a custom one. Merged data transformation \u00b6 You can apply any transformation to already merged data This step uses DokkaCore.documentableTransformer entry point. All extensions registered using this entry point will be invoked. Each of them is required to implement DocumentableTransformer interface: interface DocumentableTransformer { operator fun invoke ( original : DModule , context : DokkaContext ): DModule } By default, InheritorsExtractorTransformer is created, that extracts inherited classes data across source sets and creates inheritance map. Creating page models \u00b6 The documentable model is translated into page format, that aggregates all tha data that will be available for different pages of documentation. This step uses DokkaCore.documentableToPageTranslator entry point. It is required to have exactly one extension registered for this entry point. Having more will trigger an error, unless only one is not overridden. The extension is required to implement DocumentableToPageTranslator interface: interface DocumentableToPageTranslator { operator fun invoke ( module : DModule ): ModulePageNode } By default, DefaultDocumentableToPageTranslator is created. This extension is treated as a fallback, so it can be overridden by a custom one. Transforming page models \u00b6 You can apply any transformations to paged data. This step uses DokkaCore.pageTransformer entry point. All extensions registered using this entry point will be invoked. Each of them is required to implement PageTransformer interface: interface PageTransformer { operator fun invoke ( input : RootPageNode ): RootPageNode } By default, two transformers are created: PageMerger merges some pages depending on MergeStrategy DeprecatedStrikethroughTransformer marks all deprecated members on every page Rendering \u00b6 All pages are rendered to desired format. This step uses DokkaCore.renderer entry point. It is required to have exactly one extension registered for this entry point. Having more will trigger an error, unless only one is not overridden. The extension is required to implement Renderer interface: interface Renderer { fun render ( root : RootPageNode ) } By default, only HtmlRenderer , that extends basic DefaultRenderer , is created, but it will be registered only if configuration parameter format is set to html . Using any other value without providing valid renderer will cause Dokka to fail. Multimodule page generation endpoints \u00b6 Multimodule page generation is a separate process, that declares two additional entry points: Multimodule page creation \u00b6 Generation of the page that points to all module for which we generates documentation. This step uses CoreExtensions.allModulePageCreator entry point. It is required to have exactly one extension registered for this entry point. Having more will trigger an error, unless only one is not overridden. The extension is required to implement PageCreator interface: interface PageCreator { operator fun invoke (): RootPageNode } By default, MultimodulePageCreator is created. This extension is treated as a fallback, so it can be replaced by a custom one. Multimodule page transformation \u00b6 Additional transformation that we might apply for multimodule page. This step uses CoreExtensions.allModulePageTransformer entry point. All extensions registered using this entry point will be invoked. Each of them is required to implement common PageTransformer interface. Default extensions' extension points \u00b6 Default core extension points already have an implementation for providing basic Dokka functionality. All of them are declared in DokkaBase plugin. If you don't want this default extensions to load, all you need to do is not load Dokka base and load your plugin instead. ```kotlin val customPlugin by configurations.creating dependencies { customPlugin(\"[custom plugin load signature]\") } tasks { val dokka by getting(DokkaTask::class) { pluginsConfig = alternativeAndIndependentPlugins outputDirectory = dokkaOutputDir outputFormat = \"html\" [...] } } You will then need to implement extensions for all core extension points. `DokkaBase` also register several new extension points, with which you can change default behaviour of `DokkaBase` extensions. In order to use them, you need to add `dokka-base` to you dependencies: ```kotlin compileOnly(\"org.jetbrains.dokka:dokka-base:<dokka_version>\") Then, you need to obtain DokkaBase instance using plugin function: class SamplePlugin : DokkaPlugin () { val dokkaBase = plugin < DokkaBase >() val extension by extending { dokkaBase . pageMergerStrategy with SamplePageMergerStrategy order { before ( dokkaBase . fallbackMerger ) } } } object SamplePageMergerStrategy : PageMergerStrategy { override fun tryMerge ( pages : List < PageNode >, path : List < String >): List < PageNode > { ... } } Following extension points are available with base plugin \u00b6 Entry point Function Required interface Used by Singular Preregistered extensions pageMergerStrategy determines what kind of pages should be merged PageMergerStrategy PageMerger false FallbackPageMergerStrategy SameMethodNamePageMergerStrategy commentsToContentConverter transforms comment model into page content model CommentsToContentConverter DefaultDocumentableToPageTransformer SignatureProvider true DocTagToContentConverter signatureProvider provides representation of methods signatures SignatureProvider DefaultDocumentableToPageTransformer true KotlinSignatureProvider locationProviderFactory provides LocationProvider instance that returns paths for requested elements LocationProviderFactory DefaultRenderer HtmlRenderer PackageListService true DefaultLocationProviderFactory which returns DefaultLocationProvider externalLocationProviderFactory provides ExternalLocationProvider instance that returns paths for elements that are not part of generated documentation ExternalLocationProviderFactory DefaultLocationProvider false JavadocExternalLocationProviderFactory DokkaExternalLocationProviderFactory outputWriter writes rendered pages files OutputWriter DefaultRenderer HtmlRenderer true FileWriter htmlPreprocessors transforms page content before HTML rendering PageTransformer DefaultRenderer HtmlRenderer false RootCreator SourceLinksTransformer NavigationPageInstaller SearchPageInstaller ResourceInstaller StyleAndScriptsAppender PackageListCreator samplesTransformer transforms content for code samples for HTML rendering SamplesTransformer HtmlRenderer true DefaultSamplesTransformer","title":"Extension points"},{"location":"developer_guide/extension_points/#extension-points","text":"","title":"Extension points"},{"location":"developer_guide/extension_points/#core-extension-points","text":"We will discuss all base extension points along with the steps, that DokkaGenerator does to build a documentation.","title":"Core extension points"},{"location":"developer_guide/extension_points/#setting-up-kotlin-and-java-analysis-process-and-initializing-plugins","text":"The provided Maven / CLI / Gradle configuration is read.Then, all the DokkaPlugin classes are loaded and the extensions are created. No entry points here.","title":"Setting up Kotlin and Java analysis process and initializing plugins"},{"location":"developer_guide/extension_points/#creating-documentation-models","text":"The documentation models are created. This step uses DokkaCore.sourceToDocumentableTranslator entry point. All extensions registered using this entry point will be invoked. Each of them is required to implement SourceToDocumentableTranslator interface: interface SourceToDocumentableTranslator { fun invoke ( sourceSet : SourceSetData , context : DokkaContext ): DModule } By default, two translators are created: DefaultDescriptorToDocumentableTranslator that handles Kotlin files DefaultPsiToDocumentableTranslator that handles Java files After this step, all data from different source sets and languages are kept separately. If you are using Kotlin it is recommended to make use of the asynchronous version, providing you implementation of invokeSuspending : interface AsyncSourceToDocumentableTranslator : SourceToDocumentableTranslator { suspend fun invokeSuspending ( sourceSet : DokkaConfiguration . DokkaSourceSet , context : DokkaContext ): DModule }","title":"Creating documentation models"},{"location":"developer_guide/extension_points/#pre-merge-documentation-transform","text":"Here you can apply any transformation to model data before different source sets are merged. This step uses DokkaCore.preMergeDocumentableTransformer entry point. All extensions registered using this entry point will be invoked. Each of them is required to implement PreMergeDocumentableTransformer interface: interface PreMergeDocumentableTransformer { operator fun invoke ( modules : List < DModule >, context : DokkaContext ): List < DModule > } By default, three transformers are created: DocumentableVisibilityFilter that, depending on configuration, filters out all private members from declared packages ActualTypealiasAdder that handles Kotlin typealiases ModuleAndPackageDocumentationTransformer that creates documentation content for models and packages itself","title":"Pre-merge documentation transform"},{"location":"developer_guide/extension_points/#merging","text":"All DModule instances are merged into one. This step uses DokkaCore.documentableMerger entry point. It is required to have exactly one extension registered for this entry point. Having more will trigger an error, unless only one is not overridden. The extension is required to implement DocumentableMerger interface: interface DocumentableMerger { operator fun invoke ( modules : Collection < DModule >, context : DokkaContext ): DModule } By default, DefaultDocumentableMerger is created. This extension is treated as a fallback, so it can be overridden by a custom one.","title":"Merging"},{"location":"developer_guide/extension_points/#merged-data-transformation","text":"You can apply any transformation to already merged data This step uses DokkaCore.documentableTransformer entry point. All extensions registered using this entry point will be invoked. Each of them is required to implement DocumentableTransformer interface: interface DocumentableTransformer { operator fun invoke ( original : DModule , context : DokkaContext ): DModule } By default, InheritorsExtractorTransformer is created, that extracts inherited classes data across source sets and creates inheritance map.","title":"Merged data transformation"},{"location":"developer_guide/extension_points/#creating-page-models","text":"The documentable model is translated into page format, that aggregates all tha data that will be available for different pages of documentation. This step uses DokkaCore.documentableToPageTranslator entry point. It is required to have exactly one extension registered for this entry point. Having more will trigger an error, unless only one is not overridden. The extension is required to implement DocumentableToPageTranslator interface: interface DocumentableToPageTranslator { operator fun invoke ( module : DModule ): ModulePageNode } By default, DefaultDocumentableToPageTranslator is created. This extension is treated as a fallback, so it can be overridden by a custom one.","title":"Creating page models"},{"location":"developer_guide/extension_points/#transforming-page-models","text":"You can apply any transformations to paged data. This step uses DokkaCore.pageTransformer entry point. All extensions registered using this entry point will be invoked. Each of them is required to implement PageTransformer interface: interface PageTransformer { operator fun invoke ( input : RootPageNode ): RootPageNode } By default, two transformers are created: PageMerger merges some pages depending on MergeStrategy DeprecatedStrikethroughTransformer marks all deprecated members on every page","title":"Transforming page models"},{"location":"developer_guide/extension_points/#rendering","text":"All pages are rendered to desired format. This step uses DokkaCore.renderer entry point. It is required to have exactly one extension registered for this entry point. Having more will trigger an error, unless only one is not overridden. The extension is required to implement Renderer interface: interface Renderer { fun render ( root : RootPageNode ) } By default, only HtmlRenderer , that extends basic DefaultRenderer , is created, but it will be registered only if configuration parameter format is set to html . Using any other value without providing valid renderer will cause Dokka to fail.","title":"Rendering"},{"location":"developer_guide/extension_points/#multimodule-page-generation-endpoints","text":"Multimodule page generation is a separate process, that declares two additional entry points:","title":"Multimodule page generation endpoints"},{"location":"developer_guide/extension_points/#multimodule-page-creation","text":"Generation of the page that points to all module for which we generates documentation. This step uses CoreExtensions.allModulePageCreator entry point. It is required to have exactly one extension registered for this entry point. Having more will trigger an error, unless only one is not overridden. The extension is required to implement PageCreator interface: interface PageCreator { operator fun invoke (): RootPageNode } By default, MultimodulePageCreator is created. This extension is treated as a fallback, so it can be replaced by a custom one.","title":"Multimodule page creation"},{"location":"developer_guide/extension_points/#multimodule-page-transformation","text":"Additional transformation that we might apply for multimodule page. This step uses CoreExtensions.allModulePageTransformer entry point. All extensions registered using this entry point will be invoked. Each of them is required to implement common PageTransformer interface.","title":"Multimodule page transformation"},{"location":"developer_guide/extension_points/#default-extensions-extension-points","text":"Default core extension points already have an implementation for providing basic Dokka functionality. All of them are declared in DokkaBase plugin. If you don't want this default extensions to load, all you need to do is not load Dokka base and load your plugin instead. ```kotlin val customPlugin by configurations.creating dependencies { customPlugin(\"[custom plugin load signature]\") } tasks { val dokka by getting(DokkaTask::class) { pluginsConfig = alternativeAndIndependentPlugins outputDirectory = dokkaOutputDir outputFormat = \"html\" [...] } } You will then need to implement extensions for all core extension points. `DokkaBase` also register several new extension points, with which you can change default behaviour of `DokkaBase` extensions. In order to use them, you need to add `dokka-base` to you dependencies: ```kotlin compileOnly(\"org.jetbrains.dokka:dokka-base:<dokka_version>\") Then, you need to obtain DokkaBase instance using plugin function: class SamplePlugin : DokkaPlugin () { val dokkaBase = plugin < DokkaBase >() val extension by extending { dokkaBase . pageMergerStrategy with SamplePageMergerStrategy order { before ( dokkaBase . fallbackMerger ) } } } object SamplePageMergerStrategy : PageMergerStrategy { override fun tryMerge ( pages : List < PageNode >, path : List < String >): List < PageNode > { ... } }","title":"Default extensions' extension points"},{"location":"developer_guide/extension_points/#following-extension-points-are-available-with-base-plugin","text":"Entry point Function Required interface Used by Singular Preregistered extensions pageMergerStrategy determines what kind of pages should be merged PageMergerStrategy PageMerger false FallbackPageMergerStrategy SameMethodNamePageMergerStrategy commentsToContentConverter transforms comment model into page content model CommentsToContentConverter DefaultDocumentableToPageTransformer SignatureProvider true DocTagToContentConverter signatureProvider provides representation of methods signatures SignatureProvider DefaultDocumentableToPageTransformer true KotlinSignatureProvider locationProviderFactory provides LocationProvider instance that returns paths for requested elements LocationProviderFactory DefaultRenderer HtmlRenderer PackageListService true DefaultLocationProviderFactory which returns DefaultLocationProvider externalLocationProviderFactory provides ExternalLocationProvider instance that returns paths for elements that are not part of generated documentation ExternalLocationProviderFactory DefaultLocationProvider false JavadocExternalLocationProviderFactory DokkaExternalLocationProviderFactory outputWriter writes rendered pages files OutputWriter DefaultRenderer HtmlRenderer true FileWriter htmlPreprocessors transforms page content before HTML rendering PageTransformer DefaultRenderer HtmlRenderer false RootCreator SourceLinksTransformer NavigationPageInstaller SearchPageInstaller ResourceInstaller StyleAndScriptsAppender PackageListCreator samplesTransformer transforms content for code samples for HTML rendering SamplesTransformer HtmlRenderer true DefaultSamplesTransformer","title":"Following extension points are available with base plugin"},{"location":"developer_guide/introduction/","text":"Guide to Dokka Plugin development \u00b6 Building Dokka \u00b6 Dokka is built with Gradle. To build it, use ./gradlew build . Alternatively, open the project directory in IntelliJ IDEA and use the IDE to build and run Dokka. Here's how to import and configure Dokka in IntelliJ IDEA 2019.3: Select \"Open\" from the IDEA welcome screen, or File > Open if a project is already open Select the directory with your clone of Dokka Note IDEA may have an error after the project is initally opened; it is OK to ignore this as the next step will address this error After IDEA opens the project, select File > New > Module from existing sources and select the build.gradle.kts file from the root directory of your Dokka clone After Dokka is loaded into IDEA, open the Gradle tool window (View > Tool Windows > Gradle) and click on the top left \"Refresh all Gradle projects\" button Configuration \u00b6 tldr: you can use a convenient plugin template to speed up the setup. Dokka requires configured Kotlin plugin and dokka-core dependency. plugins { kotlin ( \"jvm\" ) version \"<kotlin_version>\" } dependencies { compileOnly ( \"org.jetbrains.dokka:dokka-core:<dokka_version>\" ) } tasks . withType < KotlinCompile > { kotlinOptions . jvmTarget = \"1.8\" } Building sample plugin \u00b6 In order to load a plugin into Dokka, your class must extend DokkaPlugin class. A fully qualified name of that class must be placed in a file named org.jetbrains.dokka.plugability.DokkaPlugin under resources/META-INF/services . All instances are automatically loaded during Dokka setup using java.util.ServiceLoader . Dokka provides a set of entry points, for which user can create their own implementations. They must be delegated using DokkaPlugin.extending(definition: ExtendingDSL.() -> Extension<T, *, *>) function,that returns a delegate ExtensionProvider with supplied definition. To create a definition, you can use one of two infix functions with(T) or providing( (DokkaContext) -> T) where T is the type of an extended endpoint. You can also use infix functions: applyIf( () -> Boolean ) to add additional condition specifying whether or not the extension should be used order((OrderDsl.() -> Unit)) to determine if your extension should be used before or after another particular extension for the same endpoint override( Extension<T, *, *> ) to override other extension. Overridden extension won't be loaded and overridding one will inherit ordering from it. Following sample provides custom translator object as a DokkaCore.sourceToDocumentableTranslator package org.jetbrains.dokka.sample import org.jetbrains.dokka.plugability.DokkaPlugin class SamplePlugin : DokkaPlugin () { extension by extending { DokkaCore . sourceToDocumentableTranslator with CustomSourceToDocumentableTranslator } } object CustomSourceToDocumentableTranslator : SourceToDocumentableTranslator { override fun invoke ( sourceSet : SourceSetData , context : DokkaContext ): DModule } Registering extension point \u00b6 You can register your own extension point using extensionPoint function declared in DokkaPlugin class class SamplePlugin : DokkaPlugin () { val extensionPoint by extensionPoint < SampleExtensionPointInterface >() } interface SampleExtensionPointInterface Obtaining extension instance \u00b6 All registered plugins are accessible with DokkaContext.plugin function. All plugins that extends DokkaPlugin can use DokkaPlugin.plugin function, that uses underlying DokkaContext instance. If you want to pass context to your extension, you can obtain it using aforementioned providing infix function. With plugin instance obtained, you can browse extensions registered for this plugins' extension points using querySingle and query methods: context . plugin < DokkaBase >(). query { htmlPreprocessors } context . plugin < DokkaBase >(). querySingle { samplesTransformer } You can also browse DokkaContext directly, using single and get methods: class SamplePlugin : DokkaPlugin () { val extensionPoint by extensionPoint < SampleExtensionPointInterface >() val anotherExtensionPoint by extensionPoint < AnotherSampleExtensionPointInterface >() val extension by extending { extensionPoint with SampleExtension () } val anotherExtension by extending { anotherExtensionPoint providing { context -> AnotherSampleExtension ( context . single ( extensionPoint )) } } } interface SampleExtensionPointInterface interface AnotherSampleExtensionPointInterface class SampleExtension : SampleExtensionPointInterface class AnotherSampleExtension ( sampleExtension : SampleExtensionPointInterface ): AnotherSampleExtensionPointInterface","title":"Introduction"},{"location":"developer_guide/introduction/#guide-to-dokka-plugin-development","text":"","title":"Guide to Dokka Plugin development"},{"location":"developer_guide/introduction/#building-dokka","text":"Dokka is built with Gradle. To build it, use ./gradlew build . Alternatively, open the project directory in IntelliJ IDEA and use the IDE to build and run Dokka. Here's how to import and configure Dokka in IntelliJ IDEA 2019.3: Select \"Open\" from the IDEA welcome screen, or File > Open if a project is already open Select the directory with your clone of Dokka Note IDEA may have an error after the project is initally opened; it is OK to ignore this as the next step will address this error After IDEA opens the project, select File > New > Module from existing sources and select the build.gradle.kts file from the root directory of your Dokka clone After Dokka is loaded into IDEA, open the Gradle tool window (View > Tool Windows > Gradle) and click on the top left \"Refresh all Gradle projects\" button","title":"Building Dokka"},{"location":"developer_guide/introduction/#configuration","text":"tldr: you can use a convenient plugin template to speed up the setup. Dokka requires configured Kotlin plugin and dokka-core dependency. plugins { kotlin ( \"jvm\" ) version \"<kotlin_version>\" } dependencies { compileOnly ( \"org.jetbrains.dokka:dokka-core:<dokka_version>\" ) } tasks . withType < KotlinCompile > { kotlinOptions . jvmTarget = \"1.8\" }","title":"Configuration"},{"location":"developer_guide/introduction/#building-sample-plugin","text":"In order to load a plugin into Dokka, your class must extend DokkaPlugin class. A fully qualified name of that class must be placed in a file named org.jetbrains.dokka.plugability.DokkaPlugin under resources/META-INF/services . All instances are automatically loaded during Dokka setup using java.util.ServiceLoader . Dokka provides a set of entry points, for which user can create their own implementations. They must be delegated using DokkaPlugin.extending(definition: ExtendingDSL.() -> Extension<T, *, *>) function,that returns a delegate ExtensionProvider with supplied definition. To create a definition, you can use one of two infix functions with(T) or providing( (DokkaContext) -> T) where T is the type of an extended endpoint. You can also use infix functions: applyIf( () -> Boolean ) to add additional condition specifying whether or not the extension should be used order((OrderDsl.() -> Unit)) to determine if your extension should be used before or after another particular extension for the same endpoint override( Extension<T, *, *> ) to override other extension. Overridden extension won't be loaded and overridding one will inherit ordering from it. Following sample provides custom translator object as a DokkaCore.sourceToDocumentableTranslator package org.jetbrains.dokka.sample import org.jetbrains.dokka.plugability.DokkaPlugin class SamplePlugin : DokkaPlugin () { extension by extending { DokkaCore . sourceToDocumentableTranslator with CustomSourceToDocumentableTranslator } } object CustomSourceToDocumentableTranslator : SourceToDocumentableTranslator { override fun invoke ( sourceSet : SourceSetData , context : DokkaContext ): DModule }","title":"Building sample plugin"},{"location":"developer_guide/introduction/#registering-extension-point","text":"You can register your own extension point using extensionPoint function declared in DokkaPlugin class class SamplePlugin : DokkaPlugin () { val extensionPoint by extensionPoint < SampleExtensionPointInterface >() } interface SampleExtensionPointInterface","title":"Registering extension point"},{"location":"developer_guide/introduction/#obtaining-extension-instance","text":"All registered plugins are accessible with DokkaContext.plugin function. All plugins that extends DokkaPlugin can use DokkaPlugin.plugin function, that uses underlying DokkaContext instance. If you want to pass context to your extension, you can obtain it using aforementioned providing infix function. With plugin instance obtained, you can browse extensions registered for this plugins' extension points using querySingle and query methods: context . plugin < DokkaBase >(). query { htmlPreprocessors } context . plugin < DokkaBase >(). querySingle { samplesTransformer } You can also browse DokkaContext directly, using single and get methods: class SamplePlugin : DokkaPlugin () { val extensionPoint by extensionPoint < SampleExtensionPointInterface >() val anotherExtensionPoint by extensionPoint < AnotherSampleExtensionPointInterface >() val extension by extending { extensionPoint with SampleExtension () } val anotherExtension by extending { anotherExtensionPoint providing { context -> AnotherSampleExtension ( context . single ( extensionPoint )) } } } interface SampleExtensionPointInterface interface AnotherSampleExtensionPointInterface class SampleExtension : SampleExtensionPointInterface class AnotherSampleExtension ( sampleExtension : SampleExtensionPointInterface ): AnotherSampleExtensionPointInterface","title":"Obtaining extension instance"},{"location":"user_guide/introduction/","text":"Introduction \u00b6 Plugins \u00b6 Dokka can be customized with plugins. Each output format is internally a plugin. Additionally, kotlin-as-java plugin can be used to generate documentation as seen from Java perspective. Currently maintained plugins are: dokka-base - the main plugin needed to run Dokka, contains html format gfm-plugin - configures GFM output format jekyll-plugin - configures Jekyll output format javadoc-plugin - configures Javadoc output format, automatically applies kotlin-as-java-plugin kotlin-as-java-plugin - translates Kotlin definitions to Java Please see the usage instructions for each build system on how to add plugins to Dokka. Source sets \u00b6 Dokka generates documentation based on source sets. For single-platform & multi-platform projects, source sets are the same as in Kotlin plugin: One source set for each platform, eg. jvmMain or jsMain ; One source set for each common source set, eg. the default commonMain and custom ones like jsAndJvmMain . When configuring multi-platform projects manually (eg. in the CLI or in Gradle without the Kotlin Gradle Plugin) source sets must declare their dependent source sets. Eg. in the following Kotlin plugin configuration: jsMain and jvmMain both depend on commonMain (by default and transitively) and jsAndJvmMain ; linuxX64Main only depends on commonMain . kotlin { // Kotlin plugin configuration jvm () js () linuxX64 () sourceSets { val commonMain by getting {} val jvmAndJsSecondCommonMain by creating { dependsOn ( commonMain ) } val jvmMain by getting { dependsOn ( jvmAndJsSecondCommonMain ) } val jsMain by getting { dependsOn ( jvmAndJsSecondCommonMain ) } val linuxX64Main by getting { dependsOn ( commonMain ) } } } Output formats \u00b6 Dokka documents Java classes as seen in Kotlin by default, with javadoc format being the only exception. html - HTML format used by default javadoc - looks like JDK's Javadoc, Kotlin classes are translated to Java gfm - GitHub flavored markdown jekyll - Jekyll compatible markdown If you want to generate the documentation as seen from Java perspective, you can add the kotlin-as-java plugin to the Dokka plugins classpath, eg. in Gradle: dependencies { implementation ( \"...\" ) dokkaGfmPlugin ( \"org.jetbrains.dokka:kotlin-as-java-plugin:${dokka-version}\" ) } Platforms \u00b6 Each Dokka source set is analyzed for a specific platform. The platform should be extracted automatically from the Kotlin plugin. In case of a manual source set configuration, you have to select one of the following: jvm js native common","title":"Introduction"},{"location":"user_guide/introduction/#introduction","text":"","title":"Introduction"},{"location":"user_guide/introduction/#plugins","text":"Dokka can be customized with plugins. Each output format is internally a plugin. Additionally, kotlin-as-java plugin can be used to generate documentation as seen from Java perspective. Currently maintained plugins are: dokka-base - the main plugin needed to run Dokka, contains html format gfm-plugin - configures GFM output format jekyll-plugin - configures Jekyll output format javadoc-plugin - configures Javadoc output format, automatically applies kotlin-as-java-plugin kotlin-as-java-plugin - translates Kotlin definitions to Java Please see the usage instructions for each build system on how to add plugins to Dokka.","title":"Plugins"},{"location":"user_guide/introduction/#source-sets","text":"Dokka generates documentation based on source sets. For single-platform & multi-platform projects, source sets are the same as in Kotlin plugin: One source set for each platform, eg. jvmMain or jsMain ; One source set for each common source set, eg. the default commonMain and custom ones like jsAndJvmMain . When configuring multi-platform projects manually (eg. in the CLI or in Gradle without the Kotlin Gradle Plugin) source sets must declare their dependent source sets. Eg. in the following Kotlin plugin configuration: jsMain and jvmMain both depend on commonMain (by default and transitively) and jsAndJvmMain ; linuxX64Main only depends on commonMain . kotlin { // Kotlin plugin configuration jvm () js () linuxX64 () sourceSets { val commonMain by getting {} val jvmAndJsSecondCommonMain by creating { dependsOn ( commonMain ) } val jvmMain by getting { dependsOn ( jvmAndJsSecondCommonMain ) } val jsMain by getting { dependsOn ( jvmAndJsSecondCommonMain ) } val linuxX64Main by getting { dependsOn ( commonMain ) } } }","title":"Source sets"},{"location":"user_guide/introduction/#output-formats","text":"Dokka documents Java classes as seen in Kotlin by default, with javadoc format being the only exception. html - HTML format used by default javadoc - looks like JDK's Javadoc, Kotlin classes are translated to Java gfm - GitHub flavored markdown jekyll - Jekyll compatible markdown If you want to generate the documentation as seen from Java perspective, you can add the kotlin-as-java plugin to the Dokka plugins classpath, eg. in Gradle: dependencies { implementation ( \"...\" ) dokkaGfmPlugin ( \"org.jetbrains.dokka:kotlin-as-java-plugin:${dokka-version}\" ) }","title":"Output formats"},{"location":"user_guide/introduction/#platforms","text":"Each Dokka source set is analyzed for a specific platform. The platform should be extracted automatically from the Kotlin plugin. In case of a manual source set configuration, you have to select one of the following: jvm js native common","title":"Platforms"},{"location":"user_guide/base-specific/frontend/","text":"Configuration specific to HTML format \u00b6 Important Concepts specified below apply only to configuration of the Base Plugin (that contains Html format) and needs to be applied via pluginsConfiguration and not on the root one. Modifying assets \u00b6 It is possible to change static assets that are used to generate dokka's HTML. Currently, user can modify: customAssets customStyleSheets Every file provided in those values will be applied to every page. Dokka uses 3 stylesheets: style.css - main css file responsible for styling the page jetbrains-mono.css - fonts used across dokka logo-styles.css - logo styling User can choose to add or override those files. Resources will be overridden when in pluginConfiguration block there is a resource with the same name. Modifying footer \u00b6 Dokka supports custom messages in the footer via footerMessage string property on base plugin configuration. Keep in mind that this value will be pased exactly to the output html, so it has to be valid and escaped correctly. Separating inherited members \u00b6 By setting a boolean property separateInheritedMembers dokka will split inherited members (like functions, properties etc.) from ones declared in viewed class. Separated members will have it's own tabs on the page. Examples \u00b6 In order to override a logo and style it accordingly a simple css file named logo-styles.css is needed: # logo { background-image : url ( 'https://upload.wikimedia.org/wikipedia/commons/9/9d/Ubuntu_logo.svg' ); /* other styles required to make your page pretty */ } For build system specific instructions please visit dedicated pages: gradle , maven and cli","title":"Html frontend"},{"location":"user_guide/base-specific/frontend/#configuration-specific-to-html-format","text":"Important Concepts specified below apply only to configuration of the Base Plugin (that contains Html format) and needs to be applied via pluginsConfiguration and not on the root one.","title":"Configuration specific to HTML format"},{"location":"user_guide/base-specific/frontend/#modifying-assets","text":"It is possible to change static assets that are used to generate dokka's HTML. Currently, user can modify: customAssets customStyleSheets Every file provided in those values will be applied to every page. Dokka uses 3 stylesheets: style.css - main css file responsible for styling the page jetbrains-mono.css - fonts used across dokka logo-styles.css - logo styling User can choose to add or override those files. Resources will be overridden when in pluginConfiguration block there is a resource with the same name.","title":"Modifying assets"},{"location":"user_guide/base-specific/frontend/#modifying-footer","text":"Dokka supports custom messages in the footer via footerMessage string property on base plugin configuration. Keep in mind that this value will be pased exactly to the output html, so it has to be valid and escaped correctly.","title":"Modifying footer"},{"location":"user_guide/base-specific/frontend/#separating-inherited-members","text":"By setting a boolean property separateInheritedMembers dokka will split inherited members (like functions, properties etc.) from ones declared in viewed class. Separated members will have it's own tabs on the page.","title":"Separating inherited members"},{"location":"user_guide/base-specific/frontend/#examples","text":"In order to override a logo and style it accordingly a simple css file named logo-styles.css is needed: # logo { background-image : url ( 'https://upload.wikimedia.org/wikipedia/commons/9/9d/Ubuntu_logo.svg' ); /* other styles required to make your page pretty */ } For build system specific instructions please visit dedicated pages: gradle , maven and cli","title":"Examples"},{"location":"user_guide/cli/usage/","text":"Using command line \u00b6 To run Dokka from the command line, download the Dokka CLI runner . To generate documentation, run the following command: java -jar dokka-cli.jar <arguments> Configuration options \u00b6 Dokka supports the following command line arguments: -outputDir - the output directory where the documentation is generated -moduleName - (required) - module name used as a part of source set ID when declaring dependent source sets -cacheRoot - cache directory to enable package-list caching -pluginsClasspath - artifacts with Dokka plugins, separated by ; . At least dokka-base and all its dependencies must be added there -pluginsConfiguration - configuration for plugins in format fqPluginName=json^^fqPluginName=json... -offlineMode - do not resolve package-lists online -failOnWarning - throw an exception instead of a warning -globalPackageOptions - per package options added to all source sets -globalLinks - external documentation links added to all source sets -globalSrcLink - source links added to all source sets -sourceSet - (repeatable) - configuration for a single source set. Following this argument, you can pass other arguments: -sourceSetName - source set name as a part of source set ID when declaring dependent source sets -displayName - source set name displayed in the generated documentation -src - list of source files or directories separated by ; -classpath - list of directories or .jar files to include in the classpath (used for resolving references) separated by ; -samples - list of directories containing sample code (documentation for those directories is not generated but declarations from them can be referenced using the @sample tag) separated by ; -includes - list of files containing the documentation for the module and individual packages separated by ; -includeNonPublic - include protected and private code -skipDeprecated - if set, deprecated elements are not included in the generated documentation -reportUndocumented - warn about undocumented members -skipEmptyPackages - do not create index pages for empty packages -packageOptions - list of package options in format matchingRegex,-deprecated,-privateApi,+reportUndocumented;matchingRegex, ... , separated by ; -links - list of external documentation links in format url^packageListUrl^^url2... , separated by ; -srcLink - mapping between a source directory and a Web site for browsing the code in format <path>=<url>[#lineSuffix] -noStdlibLink - disable linking to online kotlin-stdlib documentation -noJdkLink - disable linking to online JDK documentation -jdkVersion - version of JDK to use for linking to JDK JavaDoc -analysisPlatform - platform used for analysis, see the Platforms section -dependentSourceSets - list of dependent source sets in format moduleName/sourceSetName , separated by ; You can also use a JSON file with Dokka configuration: java -jar <dokka_cli.jar> <path_to_config.json> Applying plugins \u00b6 To apply a Dokka plugin you have to provide it and all its dependencies in the pluginsClasspath parameter Base plugin \u00b6 Using CLI runner to generate default documentation requires providing all dependencies manually on classpath. For Base plugins these are: dokka-base.jar dokka-analysis.jar kotlin-analysis-compiler.jar kotlin-analysis-intellij.jar kotlinx-coroutines-core.jar kotlinx-html-jvm.jar All of them are published on maven central. To get them on classpath one should add them via pluginsClasspath argument, e. g. java -jar dokka-cli.jar -pluginsClasspath \"dokka-base.jar;dokka-analysis.jar;kotlin-analysis-compiler.jar;kotlin-analysis-intellij.jar;kotlinx-coroutines-core.jar;kotlinx-html-jvm.jar\" ...","title":"Command line"},{"location":"user_guide/cli/usage/#using-command-line","text":"To run Dokka from the command line, download the Dokka CLI runner . To generate documentation, run the following command: java -jar dokka-cli.jar <arguments>","title":"Using command line"},{"location":"user_guide/cli/usage/#configuration-options","text":"Dokka supports the following command line arguments: -outputDir - the output directory where the documentation is generated -moduleName - (required) - module name used as a part of source set ID when declaring dependent source sets -cacheRoot - cache directory to enable package-list caching -pluginsClasspath - artifacts with Dokka plugins, separated by ; . At least dokka-base and all its dependencies must be added there -pluginsConfiguration - configuration for plugins in format fqPluginName=json^^fqPluginName=json... -offlineMode - do not resolve package-lists online -failOnWarning - throw an exception instead of a warning -globalPackageOptions - per package options added to all source sets -globalLinks - external documentation links added to all source sets -globalSrcLink - source links added to all source sets -sourceSet - (repeatable) - configuration for a single source set. Following this argument, you can pass other arguments: -sourceSetName - source set name as a part of source set ID when declaring dependent source sets -displayName - source set name displayed in the generated documentation -src - list of source files or directories separated by ; -classpath - list of directories or .jar files to include in the classpath (used for resolving references) separated by ; -samples - list of directories containing sample code (documentation for those directories is not generated but declarations from them can be referenced using the @sample tag) separated by ; -includes - list of files containing the documentation for the module and individual packages separated by ; -includeNonPublic - include protected and private code -skipDeprecated - if set, deprecated elements are not included in the generated documentation -reportUndocumented - warn about undocumented members -skipEmptyPackages - do not create index pages for empty packages -packageOptions - list of package options in format matchingRegex,-deprecated,-privateApi,+reportUndocumented;matchingRegex, ... , separated by ; -links - list of external documentation links in format url^packageListUrl^^url2... , separated by ; -srcLink - mapping between a source directory and a Web site for browsing the code in format <path>=<url>[#lineSuffix] -noStdlibLink - disable linking to online kotlin-stdlib documentation -noJdkLink - disable linking to online JDK documentation -jdkVersion - version of JDK to use for linking to JDK JavaDoc -analysisPlatform - platform used for analysis, see the Platforms section -dependentSourceSets - list of dependent source sets in format moduleName/sourceSetName , separated by ; You can also use a JSON file with Dokka configuration: java -jar <dokka_cli.jar> <path_to_config.json>","title":"Configuration options"},{"location":"user_guide/cli/usage/#applying-plugins","text":"To apply a Dokka plugin you have to provide it and all its dependencies in the pluginsClasspath parameter","title":"Applying plugins"},{"location":"user_guide/cli/usage/#base-plugin","text":"Using CLI runner to generate default documentation requires providing all dependencies manually on classpath. For Base plugins these are: dokka-base.jar dokka-analysis.jar kotlin-analysis-compiler.jar kotlin-analysis-intellij.jar kotlinx-coroutines-core.jar kotlinx-html-jvm.jar All of them are published on maven central. To get them on classpath one should add them via pluginsClasspath argument, e. g. java -jar dokka-cli.jar -pluginsClasspath \"dokka-base.jar;dokka-analysis.jar;kotlin-analysis-compiler.jar;kotlin-analysis-intellij.jar;kotlinx-coroutines-core.jar;kotlinx-html-jvm.jar\" ...","title":"Base plugin"},{"location":"user_guide/gradle/usage/","text":"Using the Gradle plugin \u00b6 Important If you are upgrading from 0.10.x to a current release of Dokka, please have a look at our migration guide The preferred way is to use plugins block. Since Dokka is currently not published to the Gradle plugin portal, you not only need to add dokka to the build.gradle.kts file, but you also need to modify the settings.gradle.kts file: build.gradle.kts: plugins { id ( \"org.jetbrains.dokka\" ) version \"1.4.20\" } repositories { jcenter () // or maven(url=\"https://dl.bintray.com/kotlin/dokka\") } settings.gradle.kts: pluginManagement { repositories { gradlePluginPortal () jcenter () } } You can also use the legacy plugin application method with buildscript block. Note that by using the buildscript way type-safe accessors are not available in Gradle Kotlin DSL, eg. you'll have to use named<DokkaTask>(\"dokkaHtml\") instead of dokkaHtml : buildscript { repositories { jcenter () } dependencies { classpath ( \"org.jetbrains.dokka:dokka-gradle-plugin:${dokka_version}\" ) } } repositories { jcenter () // or maven(url=\"https://dl.bintray.com/kotlin/dokka\") } apply ( plugin = \"org.jetbrains.dokka\" ) The plugin adds dokkaHtml , dokkaJavadoc , dokkaGfm and dokkaJekyll tasks to the project. Each task corresponds to one output format, so you should run dokkaGfm when you want to have a documentation in GFM format. Output formats are explained in the introduction If you encounter any problems when migrating from older versions of Dokka, please see the FAQ . Minimal configuration (with custom output directory only): Kotlin tasks . dokkaHtml . configure { outputDirectory . set ( buildDir . resolve ( \"dokka\" )) } Groovy tasks . named ( \"dokkaHtml\" ) { outputDirectory . set ( buildDir . resolve ( \"dokka\" )) } Configuration options \u00b6 Dokka documents single-platform as well as multi-platform projects. Most of the configuration options are set per one source set. The available configuration options for are shown below: dokkaHtml { outputDirectory . set ( buildDir . resolve ( \"dokka\" )) // Set module name displayed in the final output moduleName . set ( \"moduleName\" ) // Use default or set to custom path to cache directory // to enable package-list caching // When this is set to default, caches are stored in $USER_HOME/.cache/dokka cacheRoot . set ( file ( \"default\" )) dokkaSourceSets { configureEach { // Or source set name, for single-platform the default source sets are `main` and `test` // Used when configuring source sets manually for declaring which source sets this one depends on dependsOn ( \"otherSourceSetName\" ) // Used to remove a source set from documentation, test source sets are suppressed by default suppress . set ( false ) // Use to include or exclude non public members includeNonPublic . set ( false ) // Do not output deprecated members. Applies globally, can be overridden by packageOptions skipDeprecated . set ( false ) // Emit warnings about not documented members. Applies globally, also can be overridden by packageOptions reportUndocumented . set ( true ) // Do not create index pages for empty packages skipEmptyPackages . set ( true ) // This name will be shown in the final output displayName . set ( \"JVM\" ) // Platform used for code analysis. See the \"Platforms\" section of this readme platform . set ( org . jetbrains . dokka . Platform . jvm ) // Property used for manual addition of files to the classpath // This property does not override the classpath collected automatically but appends to it classpath . from ( file ( \"libs/dependency.jar\" )) // List of files with module and package documentation // https://kotlinlang.org/docs/reference/kotlin-doc.html#module-and-package-documentation includes . from ( \"packages.md\" , \"extra.md\" ) // List of files or directories containing sample code (referenced with @sample tags) samples . from ( \"samples/basic.kt\" , \"samples/advanced.kt\" ) // By default, sourceRoots are taken from Kotlin Plugin and kotlinTasks, following roots will be appended to them // Repeat for multiple sourceRoots sourceRoot . from ( file ( \"src\" )) // Specifies the location of the project source code on the Web. // If provided, Dokka generates \"source\" links for each declaration. // Repeat for multiple mappings sourceLink { // Unix based directory relative path to the root of the project (where you execute gradle respectively). localDirectory . set ( file ( \"src/main/kotlin\" )) // URL showing where the source code can be accessed through the web browser remoteUrl . set ( java . net . URL ( \"https://github.com/cy6erGn0m/vertx3-lang-kotlin/blob/master/src/main/kotlin\" )) // Suffix which is used to append the line number to the URL. Use #L for GitHub remoteLineSuffix . set ( \"#L\" ) } // Used for linking to JDK documentation jdkVersion . set ( 8 ) // Disable linking to online kotlin-stdlib documentation noStdlibLink . set ( false ) // Disable linking to online JDK documentation noJdkLink . set ( false ) // Disable linking to online Android documentation (only applicable for Android projects) noAndroidSdkLink . set ( false ) // Allows linking to documentation of the project\"s dependencies (generated with Javadoc or Dokka) // Repeat for multiple links externalDocumentationLink { // Root URL of the generated documentation to link with. The trailing slash is required! url = URL ( \"https://example.com/docs/\" ) // If package-list file is located in non-standard location // packageListUrl = URL(\"file:///home/user/localdocs/package-list\") } // Allows to customize documentation generation options on a per-package basis // Repeat for multiple packageOptions // If multiple packages match the same matchingRegex, the longuest matchingRegex will be used perPackageOption { matchingRegex . set ( \"kotlin($|\\\\.).*\" ) // will match kotlin and all sub-packages of it // All options are optional, default values are below: skipDeprecated . set ( false ) reportUndocumented . set ( true ) // Emit warnings about not documented members includeNonPublic . set ( false ) } // Suppress a package perPackageOption { matchingRegex . set ( \".*\\.internal.*\" ) // will match all .internal packages and sub-packages suppress . set ( true ) } } // Configures a plugin separately from the global configuration pluginConfiguration < PluginClass , ConfigurationClass >{ // values } } } Multiplatform \u00b6 Dokka supports single-platform and multi-platform projects using source sets abstraction. For most mutli-platform projects you should assume that Dokka's source sets correspond to Kotlin plugin's source sets. All source sets are by default registered and configured automatically although test source sets are suppressed Kotlin kotlin { // Kotlin Multiplatform plugin configuration jvm () js ( \"customName\" ) } tasks . withType < DokkaTask >(). configureEach { // custom output directory outputDirectory . set ( buildDir . resolve ( \"dokka\" )) dokkaSourceSets { named ( \"customNameMain\" ) { // The same name as in Kotlin Multiplatform plugin, so the sources are fetched automatically includes . from ( \"packages.md\" , \"extra.md\" ) samples . from ( \"samples/basic.kt\" , \"samples/advanced.kt\" ) } register ( \"differentName\" ) { // Different name, so source roots must be passed explicitly displayName . set ( \"JVM\" ) platform . set ( org . jetbrains . dokka . Platform . jvm ) sourceRoots . from ( kotlin . sourceSets . getByName ( \"jvmMain\" ). kotlin . srcDirs ) sourceRoots . from ( kotlin . sourceSets . getByName ( \"commonMain\" ). kotlin . srcDirs ) } } } Note If you want to share the configuration between source sets, you can use Gradle's configureEach Applying plugins \u00b6 Dokka plugin creates Gradle configuration for each output format in the form of dokka${format}Plugin : dependencies { dokkaHtmlPlugin ( \"org.jetbrains.dokka:kotlin-as-java-plugin:1.4.20\" ) } You can also create a custom Dokka task and add plugins directly inside: val customDokkaTask by creating ( DokkaTask :: class ) { dependencies { plugins ( \"org.jetbrains.dokka:kotlin-as-java-plugin:1.4.20\" ) } } Important Please note that dokkaJavadoc task will properly document only single jvm source set To generate the documentation, use the appropriate dokka${format} Gradle task: ./gradlew dokkaHtml Some plugins can be configured separately using a plugin class and configuration class. For example: pluginConfiguration < DokkaBase , DokkaBaseConfiguration > { customAssets = listOf ( file ( \"<path to asset>\" )) customStyleSheets = listOf ( file ( \"<path to custom stylesheet>\" )) } Keep in mind, that this only works when using a buildscript (with the configured plugin on classpath) since it is not possible to import plugin's class without it. If you don't want to use a buildscript or use Kotlin version lower than 1.3.50 you can achieve the same behaviour manually: pluginsMapConfiguration . set ( mapOf ( \"<fully qualified plugin's name>\" to \"\"\"<json configuration>\"\"\" )) Android \u00b6 Important Make sure you apply Dokka after com.android.library and kotlin-android . buildscript { repositories { jcenter () } dependencies { classpath ( \"org.jetbrains.kotlin:kotlin-gradle-plugin:${kotlin_version}\" ) classpath ( \"org.jetbrains.dokka:dokka-gradle-plugin:${dokka_version}\" ) } } repositories { jcenter () } apply ( plugin = \"com.android.library\" ) apply ( plugin = \"kotlin-android\" ) apply ( plugin = \"org.jetbrains.dokka\" ) dokkaHtml . configure { dokkaSourceSets { named ( \"main\" ) { noAndroidSdkLink . set ( false ) } } } Multi-module projects \u00b6 For documenting Gradle multi-module projects, you can use dokka${format}MultiModule tasks. tasks . dokkaHtmlMultiModule . configure { outputDirectory . set ( buildDir . resolve ( \"dokkaCustomMultiModuleOutput\" )) } DokkaMultiModule depends on all Dokka tasks in the subprojects, runs them, and creates a toplevel page with links to all generated (sub)documentations Example project \u00b6 Please see the Dokka Gradle example project for an example.","title":"Gradle"},{"location":"user_guide/gradle/usage/#using-the-gradle-plugin","text":"Important If you are upgrading from 0.10.x to a current release of Dokka, please have a look at our migration guide The preferred way is to use plugins block. Since Dokka is currently not published to the Gradle plugin portal, you not only need to add dokka to the build.gradle.kts file, but you also need to modify the settings.gradle.kts file: build.gradle.kts: plugins { id ( \"org.jetbrains.dokka\" ) version \"1.4.20\" } repositories { jcenter () // or maven(url=\"https://dl.bintray.com/kotlin/dokka\") } settings.gradle.kts: pluginManagement { repositories { gradlePluginPortal () jcenter () } } You can also use the legacy plugin application method with buildscript block. Note that by using the buildscript way type-safe accessors are not available in Gradle Kotlin DSL, eg. you'll have to use named<DokkaTask>(\"dokkaHtml\") instead of dokkaHtml : buildscript { repositories { jcenter () } dependencies { classpath ( \"org.jetbrains.dokka:dokka-gradle-plugin:${dokka_version}\" ) } } repositories { jcenter () // or maven(url=\"https://dl.bintray.com/kotlin/dokka\") } apply ( plugin = \"org.jetbrains.dokka\" ) The plugin adds dokkaHtml , dokkaJavadoc , dokkaGfm and dokkaJekyll tasks to the project. Each task corresponds to one output format, so you should run dokkaGfm when you want to have a documentation in GFM format. Output formats are explained in the introduction If you encounter any problems when migrating from older versions of Dokka, please see the FAQ . Minimal configuration (with custom output directory only): Kotlin tasks . dokkaHtml . configure { outputDirectory . set ( buildDir . resolve ( \"dokka\" )) } Groovy tasks . named ( \"dokkaHtml\" ) { outputDirectory . set ( buildDir . resolve ( \"dokka\" )) }","title":"Using the Gradle plugin"},{"location":"user_guide/gradle/usage/#configuration-options","text":"Dokka documents single-platform as well as multi-platform projects. Most of the configuration options are set per one source set. The available configuration options for are shown below: dokkaHtml { outputDirectory . set ( buildDir . resolve ( \"dokka\" )) // Set module name displayed in the final output moduleName . set ( \"moduleName\" ) // Use default or set to custom path to cache directory // to enable package-list caching // When this is set to default, caches are stored in $USER_HOME/.cache/dokka cacheRoot . set ( file ( \"default\" )) dokkaSourceSets { configureEach { // Or source set name, for single-platform the default source sets are `main` and `test` // Used when configuring source sets manually for declaring which source sets this one depends on dependsOn ( \"otherSourceSetName\" ) // Used to remove a source set from documentation, test source sets are suppressed by default suppress . set ( false ) // Use to include or exclude non public members includeNonPublic . set ( false ) // Do not output deprecated members. Applies globally, can be overridden by packageOptions skipDeprecated . set ( false ) // Emit warnings about not documented members. Applies globally, also can be overridden by packageOptions reportUndocumented . set ( true ) // Do not create index pages for empty packages skipEmptyPackages . set ( true ) // This name will be shown in the final output displayName . set ( \"JVM\" ) // Platform used for code analysis. See the \"Platforms\" section of this readme platform . set ( org . jetbrains . dokka . Platform . jvm ) // Property used for manual addition of files to the classpath // This property does not override the classpath collected automatically but appends to it classpath . from ( file ( \"libs/dependency.jar\" )) // List of files with module and package documentation // https://kotlinlang.org/docs/reference/kotlin-doc.html#module-and-package-documentation includes . from ( \"packages.md\" , \"extra.md\" ) // List of files or directories containing sample code (referenced with @sample tags) samples . from ( \"samples/basic.kt\" , \"samples/advanced.kt\" ) // By default, sourceRoots are taken from Kotlin Plugin and kotlinTasks, following roots will be appended to them // Repeat for multiple sourceRoots sourceRoot . from ( file ( \"src\" )) // Specifies the location of the project source code on the Web. // If provided, Dokka generates \"source\" links for each declaration. // Repeat for multiple mappings sourceLink { // Unix based directory relative path to the root of the project (where you execute gradle respectively). localDirectory . set ( file ( \"src/main/kotlin\" )) // URL showing where the source code can be accessed through the web browser remoteUrl . set ( java . net . URL ( \"https://github.com/cy6erGn0m/vertx3-lang-kotlin/blob/master/src/main/kotlin\" )) // Suffix which is used to append the line number to the URL. Use #L for GitHub remoteLineSuffix . set ( \"#L\" ) } // Used for linking to JDK documentation jdkVersion . set ( 8 ) // Disable linking to online kotlin-stdlib documentation noStdlibLink . set ( false ) // Disable linking to online JDK documentation noJdkLink . set ( false ) // Disable linking to online Android documentation (only applicable for Android projects) noAndroidSdkLink . set ( false ) // Allows linking to documentation of the project\"s dependencies (generated with Javadoc or Dokka) // Repeat for multiple links externalDocumentationLink { // Root URL of the generated documentation to link with. The trailing slash is required! url = URL ( \"https://example.com/docs/\" ) // If package-list file is located in non-standard location // packageListUrl = URL(\"file:///home/user/localdocs/package-list\") } // Allows to customize documentation generation options on a per-package basis // Repeat for multiple packageOptions // If multiple packages match the same matchingRegex, the longuest matchingRegex will be used perPackageOption { matchingRegex . set ( \"kotlin($|\\\\.).*\" ) // will match kotlin and all sub-packages of it // All options are optional, default values are below: skipDeprecated . set ( false ) reportUndocumented . set ( true ) // Emit warnings about not documented members includeNonPublic . set ( false ) } // Suppress a package perPackageOption { matchingRegex . set ( \".*\\.internal.*\" ) // will match all .internal packages and sub-packages suppress . set ( true ) } } // Configures a plugin separately from the global configuration pluginConfiguration < PluginClass , ConfigurationClass >{ // values } } }","title":"Configuration options"},{"location":"user_guide/gradle/usage/#multiplatform","text":"Dokka supports single-platform and multi-platform projects using source sets abstraction. For most mutli-platform projects you should assume that Dokka's source sets correspond to Kotlin plugin's source sets. All source sets are by default registered and configured automatically although test source sets are suppressed Kotlin kotlin { // Kotlin Multiplatform plugin configuration jvm () js ( \"customName\" ) } tasks . withType < DokkaTask >(). configureEach { // custom output directory outputDirectory . set ( buildDir . resolve ( \"dokka\" )) dokkaSourceSets { named ( \"customNameMain\" ) { // The same name as in Kotlin Multiplatform plugin, so the sources are fetched automatically includes . from ( \"packages.md\" , \"extra.md\" ) samples . from ( \"samples/basic.kt\" , \"samples/advanced.kt\" ) } register ( \"differentName\" ) { // Different name, so source roots must be passed explicitly displayName . set ( \"JVM\" ) platform . set ( org . jetbrains . dokka . Platform . jvm ) sourceRoots . from ( kotlin . sourceSets . getByName ( \"jvmMain\" ). kotlin . srcDirs ) sourceRoots . from ( kotlin . sourceSets . getByName ( \"commonMain\" ). kotlin . srcDirs ) } } } Note If you want to share the configuration between source sets, you can use Gradle's configureEach","title":"Multiplatform"},{"location":"user_guide/gradle/usage/#applying-plugins","text":"Dokka plugin creates Gradle configuration for each output format in the form of dokka${format}Plugin : dependencies { dokkaHtmlPlugin ( \"org.jetbrains.dokka:kotlin-as-java-plugin:1.4.20\" ) } You can also create a custom Dokka task and add plugins directly inside: val customDokkaTask by creating ( DokkaTask :: class ) { dependencies { plugins ( \"org.jetbrains.dokka:kotlin-as-java-plugin:1.4.20\" ) } } Important Please note that dokkaJavadoc task will properly document only single jvm source set To generate the documentation, use the appropriate dokka${format} Gradle task: ./gradlew dokkaHtml Some plugins can be configured separately using a plugin class and configuration class. For example: pluginConfiguration < DokkaBase , DokkaBaseConfiguration > { customAssets = listOf ( file ( \"<path to asset>\" )) customStyleSheets = listOf ( file ( \"<path to custom stylesheet>\" )) } Keep in mind, that this only works when using a buildscript (with the configured plugin on classpath) since it is not possible to import plugin's class without it. If you don't want to use a buildscript or use Kotlin version lower than 1.3.50 you can achieve the same behaviour manually: pluginsMapConfiguration . set ( mapOf ( \"<fully qualified plugin's name>\" to \"\"\"<json configuration>\"\"\" ))","title":"Applying plugins"},{"location":"user_guide/gradle/usage/#android","text":"Important Make sure you apply Dokka after com.android.library and kotlin-android . buildscript { repositories { jcenter () } dependencies { classpath ( \"org.jetbrains.kotlin:kotlin-gradle-plugin:${kotlin_version}\" ) classpath ( \"org.jetbrains.dokka:dokka-gradle-plugin:${dokka_version}\" ) } } repositories { jcenter () } apply ( plugin = \"com.android.library\" ) apply ( plugin = \"kotlin-android\" ) apply ( plugin = \"org.jetbrains.dokka\" ) dokkaHtml . configure { dokkaSourceSets { named ( \"main\" ) { noAndroidSdkLink . set ( false ) } } }","title":"Android"},{"location":"user_guide/gradle/usage/#multi-module-projects","text":"For documenting Gradle multi-module projects, you can use dokka${format}MultiModule tasks. tasks . dokkaHtmlMultiModule . configure { outputDirectory . set ( buildDir . resolve ( \"dokkaCustomMultiModuleOutput\" )) } DokkaMultiModule depends on all Dokka tasks in the subprojects, runs them, and creates a toplevel page with links to all generated (sub)documentations","title":"Multi-module projects"},{"location":"user_guide/gradle/usage/#example-project","text":"Please see the Dokka Gradle example project for an example.","title":"Example project"},{"location":"user_guide/maven/usage/","text":"Using the Maven plugin \u00b6 Note Dokka Maven plugin does not support multi-platform projects. The Maven plugin is available in JCenter. You need to add the JCenter repository to the list of plugin repositories if it's not there: <pluginRepositories> <pluginRepository> <id> jcenter </id> <name> JCenter </name> <url> https://jcenter.bintray.com/ </url> </pluginRepository> </pluginRepositories> Minimal Maven configuration is <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> dokka-maven-plugin </artifactId> <version> ${dokka.version} </version> <executions> <execution> <phase> pre-site </phase> <goals> <goal> dokka </goal> </goals> </execution> </executions> </plugin> By default files will be generated in target/dokka . The following goals are provided by the plugin: dokka:dokka - generate HTML documentation in Dokka format (showing declarations in Kotlin syntax) dokka:javadoc - generate HTML documentation in Javadoc format (showing declarations in Java syntax) dokka:javadocJar - generate a .jar file with Javadoc format documentation Configuration options \u00b6 The available configuration options are shown below: <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> dokka-maven-plugin </artifactId> <version> ${dokka.version} </version> <executions> <execution> <phase> pre-site </phase> <goals> <goal> dokka </goal> </goals> </execution> </executions> <configuration> <!-- Set to true to skip dokka task, default: false --> <skip> false </skip> <!-- Default: ${project.artifactId} --> <moduleName> data </moduleName> <!-- Default: ${project.basedir}/target/dokka --> <outputDir> some/out/dir </outputDir> <!-- Use default or set to custom path to cache directory to enable package-list caching. --> <!-- When set to default, caches stored in $USER_HOME/.cache/dokka --> <cacheRoot> default </cacheRoot> <!-- List of '.md' files with package and module docs --> <!-- https://kotlinlang.org/docs/reference/kotlin-doc.html#module-and-package-documentation --> <includes> <include> packages.md </include> <include> extra.md </include> </includes> <!-- List of sample roots --> <samples> <dir> src/test/samples </dir> </samples> <!-- Used for linking to JDK, default: 6 --> <jdkVersion> 6 </jdkVersion> <!-- Do not output deprecated members, applies globally, can be overridden by packageOptions --> <skipDeprecated> false </skipDeprecated> <!-- Emit warnings about not documented members, applies globally, also can be overridden by packageOptions --> <reportUndocumented> true </reportUndocumented> <!-- Do not create index pages for empty packages --> <skipEmptyPackages> true </skipEmptyPackages> <!-- Short form list of sourceRoots, by default, set to ${project.compileSourceRoots} --> <sourceDirectories> <dir> src/main/kotlin </dir> </sourceDirectories> <!-- Full form list of sourceRoots --> <sourceRoots> <root> <path> src/main/kotlin </path> <!-- See platforms section of documentation --> <platforms> JVM </platforms> </root> </sourceRoots> <!-- Specifies the location of the project source code on the Web. If provided, Dokka generates \"source\" links for each declaration. --> <sourceLinks> <link> <!-- Source directory --> <path> ${project.basedir}/src/main/kotlin </path> <!-- URL showing where the source code can be accessed through the web browser --> <url> https://github.com/cy6erGn0m/vertx3-lang-kotlin/blob/master/src/main/kotlin </url> <!-- //remove src/main/kotlin if you use \"./\" above --> <!--Suffix which is used to append the line number to the URL. Use #L for GitHub --> <lineSuffix> #L </lineSuffix> </link> </sourceLinks> <!-- Disable linking to online kotlin-stdlib documentation --> <noStdlibLink> false </noStdlibLink> <!-- Disable linking to online JDK documentation --> <noJdkLink> false </noJdkLink> <!-- Allows linking to documentation of the project's dependencies (generated with Javadoc or Dokka) --> <externalDocumentationLinks> <link> <!-- Root URL of the generated documentation to link with. The trailing slash is required! --> <url> https://example.com/docs/ </url> <!-- If package-list file located in non-standard location --> <!-- <packageListUrl>file:///home/user/localdocs/package-list</packageListUrl> --> </link> </externalDocumentationLinks> <!-- Allows to customize documentation generation options on a per-package basis --> <perPackageOptions> <packageOptions> <!-- Will match kotlin and all sub-packages of it --> <matchingRegex> kotlin($|\\.).* </matchingRegex> <!-- All options are optional, default values are below: --> <skipDeprecated> false </skipDeprecated> <!-- Emit warnings about not documented members --> <reportUndocumented> true </reportUndocumented> <includeNonPublic> false </includeNonPublic> </packageOptions> </perPackageOptions> <!-- Allows to use any dokka plugin, eg. GFM format --> <dokkaPlugins> <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> gfm-plugin </artifactId> <version> ${dokka.version} </version> </plugin> </dokkaPlugins> <!-- Configures a plugin separately --> <pluginsConfiguration> <fullyQualifiedPluginName> <!-- Configuration --> </fullyQualifiedPluginName> </pluginsConfiguration> </configuration> </plugin> Applying plugins \u00b6 You can add plugins inside the dokkaPlugins block: <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> dokka-maven-plugin </artifactId> <version> ${dokka.version} </version> <executions> <execution> <phase> pre-site </phase> <goals> <goal> dokka </goal> </goals> </execution> </executions> <configuration> <dokkaPlugins> <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> kotlin-as-java-plugin </artifactId> <version> ${dokka.version} </version> </plugin> </dokkaPlugins> </configuration> </plugin> Some plugins can be configured separately using plugin's fully qualified name. For example: <pluginsConfiguration> <org.jetbrains.dokka.base.DokkaBase> <customStyleSheets> <customStyleSheet> <!-- path to custom stylesheet --> </customStyleSheet> </customStyleSheets> <customAssets> <customAsset> <!-- path to custom asset --> </customAsset> </customAssets> </org.jetbrains.dokka.base.DokkaBase> </pluginsConfiguration> Example project \u00b6 Please see the Dokka Maven example project for an example.","title":"Maven"},{"location":"user_guide/maven/usage/#using-the-maven-plugin","text":"Note Dokka Maven plugin does not support multi-platform projects. The Maven plugin is available in JCenter. You need to add the JCenter repository to the list of plugin repositories if it's not there: <pluginRepositories> <pluginRepository> <id> jcenter </id> <name> JCenter </name> <url> https://jcenter.bintray.com/ </url> </pluginRepository> </pluginRepositories> Minimal Maven configuration is <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> dokka-maven-plugin </artifactId> <version> ${dokka.version} </version> <executions> <execution> <phase> pre-site </phase> <goals> <goal> dokka </goal> </goals> </execution> </executions> </plugin> By default files will be generated in target/dokka . The following goals are provided by the plugin: dokka:dokka - generate HTML documentation in Dokka format (showing declarations in Kotlin syntax) dokka:javadoc - generate HTML documentation in Javadoc format (showing declarations in Java syntax) dokka:javadocJar - generate a .jar file with Javadoc format documentation","title":"Using the Maven plugin"},{"location":"user_guide/maven/usage/#configuration-options","text":"The available configuration options are shown below: <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> dokka-maven-plugin </artifactId> <version> ${dokka.version} </version> <executions> <execution> <phase> pre-site </phase> <goals> <goal> dokka </goal> </goals> </execution> </executions> <configuration> <!-- Set to true to skip dokka task, default: false --> <skip> false </skip> <!-- Default: ${project.artifactId} --> <moduleName> data </moduleName> <!-- Default: ${project.basedir}/target/dokka --> <outputDir> some/out/dir </outputDir> <!-- Use default or set to custom path to cache directory to enable package-list caching. --> <!-- When set to default, caches stored in $USER_HOME/.cache/dokka --> <cacheRoot> default </cacheRoot> <!-- List of '.md' files with package and module docs --> <!-- https://kotlinlang.org/docs/reference/kotlin-doc.html#module-and-package-documentation --> <includes> <include> packages.md </include> <include> extra.md </include> </includes> <!-- List of sample roots --> <samples> <dir> src/test/samples </dir> </samples> <!-- Used for linking to JDK, default: 6 --> <jdkVersion> 6 </jdkVersion> <!-- Do not output deprecated members, applies globally, can be overridden by packageOptions --> <skipDeprecated> false </skipDeprecated> <!-- Emit warnings about not documented members, applies globally, also can be overridden by packageOptions --> <reportUndocumented> true </reportUndocumented> <!-- Do not create index pages for empty packages --> <skipEmptyPackages> true </skipEmptyPackages> <!-- Short form list of sourceRoots, by default, set to ${project.compileSourceRoots} --> <sourceDirectories> <dir> src/main/kotlin </dir> </sourceDirectories> <!-- Full form list of sourceRoots --> <sourceRoots> <root> <path> src/main/kotlin </path> <!-- See platforms section of documentation --> <platforms> JVM </platforms> </root> </sourceRoots> <!-- Specifies the location of the project source code on the Web. If provided, Dokka generates \"source\" links for each declaration. --> <sourceLinks> <link> <!-- Source directory --> <path> ${project.basedir}/src/main/kotlin </path> <!-- URL showing where the source code can be accessed through the web browser --> <url> https://github.com/cy6erGn0m/vertx3-lang-kotlin/blob/master/src/main/kotlin </url> <!-- //remove src/main/kotlin if you use \"./\" above --> <!--Suffix which is used to append the line number to the URL. Use #L for GitHub --> <lineSuffix> #L </lineSuffix> </link> </sourceLinks> <!-- Disable linking to online kotlin-stdlib documentation --> <noStdlibLink> false </noStdlibLink> <!-- Disable linking to online JDK documentation --> <noJdkLink> false </noJdkLink> <!-- Allows linking to documentation of the project's dependencies (generated with Javadoc or Dokka) --> <externalDocumentationLinks> <link> <!-- Root URL of the generated documentation to link with. The trailing slash is required! --> <url> https://example.com/docs/ </url> <!-- If package-list file located in non-standard location --> <!-- <packageListUrl>file:///home/user/localdocs/package-list</packageListUrl> --> </link> </externalDocumentationLinks> <!-- Allows to customize documentation generation options on a per-package basis --> <perPackageOptions> <packageOptions> <!-- Will match kotlin and all sub-packages of it --> <matchingRegex> kotlin($|\\.).* </matchingRegex> <!-- All options are optional, default values are below: --> <skipDeprecated> false </skipDeprecated> <!-- Emit warnings about not documented members --> <reportUndocumented> true </reportUndocumented> <includeNonPublic> false </includeNonPublic> </packageOptions> </perPackageOptions> <!-- Allows to use any dokka plugin, eg. GFM format --> <dokkaPlugins> <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> gfm-plugin </artifactId> <version> ${dokka.version} </version> </plugin> </dokkaPlugins> <!-- Configures a plugin separately --> <pluginsConfiguration> <fullyQualifiedPluginName> <!-- Configuration --> </fullyQualifiedPluginName> </pluginsConfiguration> </configuration> </plugin>","title":"Configuration options"},{"location":"user_guide/maven/usage/#applying-plugins","text":"You can add plugins inside the dokkaPlugins block: <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> dokka-maven-plugin </artifactId> <version> ${dokka.version} </version> <executions> <execution> <phase> pre-site </phase> <goals> <goal> dokka </goal> </goals> </execution> </executions> <configuration> <dokkaPlugins> <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> kotlin-as-java-plugin </artifactId> <version> ${dokka.version} </version> </plugin> </dokkaPlugins> </configuration> </plugin> Some plugins can be configured separately using plugin's fully qualified name. For example: <pluginsConfiguration> <org.jetbrains.dokka.base.DokkaBase> <customStyleSheets> <customStyleSheet> <!-- path to custom stylesheet --> </customStyleSheet> </customStyleSheets> <customAssets> <customAsset> <!-- path to custom asset --> </customAsset> </customAssets> </org.jetbrains.dokka.base.DokkaBase> </pluginsConfiguration>","title":"Applying plugins"},{"location":"user_guide/maven/usage/#example-project","text":"Please see the Dokka Maven example project for an example.","title":"Example project"}]}